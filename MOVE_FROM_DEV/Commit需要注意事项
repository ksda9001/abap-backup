有一个程序修改了采购订单，又更新了一张日志表，修改采购订单使用BAPI_PO_CHANGE，然后commit work，更新日志表是直接modify 透明表；最近出现的问题是这个日志表经常的数据不对，查看程序发现最近修改是增加了调用RFC将修改后的PO发送到外部系统。问题就出在这里，调用RFC隐式的触发了数据库提交，导致后来需要rollback的也提交了。
下面说一说SAP中commit work需要知道的事情，虽然直接用的时候不多：
隐式提交（implicit commit）和显式提交（explicit commit）：
顾名思义，隐式是指没有写commit work语句也触发的数据库提交；显式是指使用commit work或者这条语句触发的提交（包含封装这条语句的function module，如DB_commit， bapi_transaction_commit等）。
在以下几种情况下，会触发隐式提交：
1，切换dialog，如call screen
2，调用RFC，如本文开始的示例
3，程序运行结束，即工作进程结束时，
4，RFC运行结束时（应包含在第3条里，为了突出RFC话题单独列出来）
5，消息输出，如打印E，I，W类型的消息
显式提交就没什么说的了，只有写上一句commit work的时候才提交。SAP总喜欢把问题复杂化。那么什么情况下用显式提交呢，有以下两种情况必须显式提交：
1，perform xxx on commit，只有等到显式的commit语句时，这个xxx才会被执行。
2，call function xxx in update task，同上
我们知道，BAPI开头的那一堆function module大部分是需要显式调用commit才会提交数据库的，这是属于第1种情况，BAPI里面使用了大量的perform on commit。
再插一下，显式commit在增强程序中可要慎之又慎，它除了会把增强中你的代码中数据更新提交，也会把主程序中的数据更新提交，一不小心数据会被搞乱的。

那么问题来了，请问我有一个程序先后调用同一个外部系统的三个RFC，怎么样才能让这三个RFC一起提交一起回滚呢？
再变态点，如果是多个外部系统呢？
太变态了，遇到这样的直接回复用户搞不了。





为什么要commit呢,百里其实自己做了个实验,就是当数据量很少的时候就是你提交不提交也就那样了 效果是一样的, 但是! 
当数据量很大的时候,sap是跟异步一样, 后续所需的数据,就会获取不到,此时就需要使用commit work and wait 进行数据处理,
变成同步.这样方便后序数据操作 .

也通过询问一些大佬了解到,其实这些数据操作是在内存中的,叫做一个session ,如果他会在内存中计算.